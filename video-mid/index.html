<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <title>p5.js schilderij in div</title>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #111;
      }

      /* de container waar jouw canvas netjes in komt */
      .img {
        width: 800px;       /* gewenste breedte */
        height: 500px;      /* gewenste hoogte */
        border: 8px solid white; /* alsof het een schilderijlijst is */
        box-shadow: 0 0 40px rgba(0,0,0,0.8);
        overflow: hidden;   /* canvas buiten de div verbergen */
        display: flex;
        justify-content: center;
        align-items: center;
        background: black;
      }

      canvas {
        width: 100%;
        height: 100%;
        object-fit: cover;  /* zodat het canvas zich aanpast */
        display: block;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  </head>
  <body>
    <div class="img" id="img"></div>

    <script>
      let particles = [];
      let flow;
      let pgTrails;
      let settings = {
        particleCount: 400,
        fieldRes: 22,
        speed: 1.1,
        trailFade: 20
      };
      let paused = false;
      let lastTime = 0;
      let palette;
      let t = 0;

      function setup() {
        // canvas in de div plaatsen
        let c = createCanvas(800, 500);
        c.parent("img");

        colorMode(HSB, 360, 100, 100, 1);
        pixelDensity(1);

        pgTrails = createGraphics(width, height);
        pgTrails.colorMode(HSB, 360, 100, 100, 1);

        flow = new FlowField(settings.fieldRes);
        palette = new Palette();

        for (let i = 0; i < settings.particleCount; i++) particles.push(new Particle());

        lastTime = millis();
      }

      function draw() {
        if (!paused) {
          let now = millis();
          let dt = (now - lastTime) / 1000;
          lastTime = now;
          t += dt;
          flow.update(t * 0.2);

          pgTrails.push();
          pgTrails.noStroke();
          pgTrails.fill(0, 0, 0, 0.05);
          pgTrails.rect(0, 0, pgTrails.width, pgTrails.height);
          pgTrails.pop();

          for (let p of particles) {
            p.follow(flow);
            p.update(dt);
            p.edges();
            p.show(pgTrails);
          }
        }

        background(6, 6, 4);
        image(pgTrails, 0, 0);
      }

      class FlowField {
        constructor(res) {
          this.res = res;
          this.cols = ceil(width / this.res) + 1;
          this.rows = ceil(height / this.res) + 1;
          this.vectors = new Array(this.cols * this.rows)
            .fill()
            .map(() => createVector());
          this.scale = 0.0016;
        }
        update(time) {
          let i = 0;
          for (let x = 0; x < this.cols; x++) {
            for (let y = 0; y < this.rows; y++) {
              let n = noise(x * this.scale, y * this.scale, time);
              let angle = TAU * n;
              let v = p5.Vector.fromAngle(angle);
              v.setMag(1);
              this.vectors[i++] = v;
            }
          }
        }
        lookup(pos) {
          let col = constrain(floor(pos.x / this.res), 0, this.cols - 1);
          let row = constrain(floor(pos.y / this.res), 0, this.rows - 1);
          let idx = col + row * this.cols;
          return this.vectors[idx] ? this.vectors[idx].copy() : createVector(0, 0);
        }
      }

      class Particle {
        constructor() {
          this.pos = createVector(random(width), random(height));
          this.prev = this.pos.copy();
          this.vel = createVector(0, 0);
          this.acc = createVector(0, 0);
          this.maxSpeed = random(0.6, 2.6) * settings.speed;
          this.size = random(0.8, 3.6);
          this.hue = (palette.baseHue + random(-30, 30)) % 360;
          this.life = random(20, 200);
        }
        follow(field) {
          let desired = field.lookup(this.pos);
          desired.mult(this.maxSpeed);
          let steer = p5.Vector.sub(desired, this.vel);
          steer.limit(0.08 + this.size * 0.003);
          this.applyForce(steer);
        }
        applyForce(f) {
          this.acc.add(f);
        }
        update(dt) {
          this.vel.add(this.acc);
          this.vel.limit(this.maxSpeed);
          this.prev = this.pos.copy();
          this.pos.add(this.vel.copy().mult(dt * 60));
          this.acc.mult(0);
          this.life -= dt * 10;
          if (this.life < 0) this.reset();
        }
        reset() {
          this.pos.set(random(width), random(height));
          this.prev = this.pos.copy();
          this.vel.mult(0);
          this.life = random(20, 200);
        }
        edges() {
          if (this.pos.x < 0) this.pos.x = width;
          if (this.pos.x > width) this.pos.x = 0;
          if (this.pos.y < 0) this.pos.y = height;
          if (this.pos.y > height) this.pos.y = 0;
        }
        show(pg) {
          pg.push();
          pg.strokeWeight(this.size);
          let s = constrain(this.vel.mag() / this.maxSpeed, 0.1, 1);
          let alpha = map(s, 0, 1, 0.08, 0.7);
          pg.stroke(this.hue, 80, 100, alpha);
          pg.line(this.prev.x, this.prev.y, this.pos.x, this.pos.y);
          pg.pop();
        }
      }

      class Palette {
        constructor() {
          this.baseHue = random(200, 260);
        }
      }
    </script>
  </body>
</html>