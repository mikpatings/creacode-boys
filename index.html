<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Super Advanced p5.js Animatie — Grote Demo</title>
  <style>
    html,body{margin:0;height:100%;background:#05060b;overflow:hidden;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    #ui{position:fixed;left:12px;top:12px;z-index:100;color:#dfe6ff;font-size:13px;backdrop-filter:blur(6px);padding:8px 10px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(0,0,0,0.06));box-shadow:0 6px 30px rgba(0,0,0,0.6)}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:8px;color:inherit}
    .muted{opacity:0.75;font-size:12px}
    #signature{position:fixed;right:12px;bottom:12px;color:rgba(255,255,255,0.25);font-size:12px}
  </style>
</head>
<body>
  <div id="ui">
    <div><strong>Super p5.js Animatie</strong> — geavanceerd flow-field + metaballs + trails</div>
    <div class="muted" id="stats">FPS: -- • Particles: --</div>
    <div style="margin-top:6px">
      <button id="btnPause">Pauze (P)</button>
      <button id="btnClear">Clear (C)</button>
      <button id="btnToggleMeta">Metaballs (M)</button>
    </div>
    <div style="margin-top:6px;font-size:12px">Klik/drag: trekt de deeltjes. Scroll: zoom field (Ctrl/Meta voor fijn)</div>
  </div>
  <div id="signature">Gebouwd met ♥ — p5.js</div>

  <!-- p5.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script>
// ------------------------------------------------------------
// Super Advanced p5.js Animation
// Single-file demo: Flow-field driven particles with trail layering,
// metaballs shader pass and subtle post-processing.
// Interactivity: mouse attractor, keyboard toggles.
// Author: ChatGPT-generated demo (customizable)
// ------------------------------------------------------------

let particles = [];
let flow;
let pgTrails;      // trails layer (2D)
let pgMeta;        // shader layer (WEBGL)
let metaballsShader;
let settings = {
  particleCount: 1200,
  fieldRes: 22,
  speed: 1.1,
  trailFade: 20,    // alpha fade per frame on trails (0-255 low means long trails)
  metaballs: true,
  fpsSmoothing: 0.05
};

let paused = false;
let lastTime = 0;
let fps = 60;
let palette;
let t = 0; // global time

function preload(){
  // embed shader source as strings
  metaballsShader = new p5.Shader(this._renderer, vertSrc, fragSrc);
}

function setup(){
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  pixelDensity(max(1, floor(displayDensity())));

  // offscreen layers
  pgTrails = createGraphics(width, height);
  pgTrails.pixelDensity(1);
  pgTrails.colorMode(HSB,360,100,100,1);

  pgMeta = createGraphics(width, height, WEBGL);
  pgMeta.pixelDensity(1);
  pgMeta.noStroke();
  pgMeta.shader(metaballsShader);

  // create flow field
  flow = new FlowField(settings.fieldRes);

  // palette
  palette = new Palette();

  // particles
  for(let i=0;i<settings.particleCount;i++) particles.push(new Particle());

  // UI
  document.getElementById('btnPause').onclick = ()=> togglePause();
  document.getElementById('btnClear').onclick = ()=> clearTrails();
  document.getElementById('btnToggleMeta').onclick = ()=> {settings.metaballs=!settings.metaballs}

  lastTime = millis();
}

function draw(){
  if(!paused){
    let now = millis();
    let dt = (now-lastTime)/1000;
    lastTime = now;
    t += dt;

    // update flow
    flow.update(t*0.2);

    // fade trails slightly (draw a transparent rectangle)
    pgTrails.push();
    pgTrails.noStroke();
    // draw translucent black to create long trails — alpha controlled by trailFade
    pgTrails.fill(0,0,0, map(settings.trailFade,0,255,0,0.06));
    pgTrails.rect(0,0,pgTrails.width, pgTrails.height);
    pgTrails.pop();

    // update particles
    for(let p of particles){
      p.follow(flow);
      p.update(dt);
      p.edges();
      p.show(pgTrails);
    }
  }

  // background subtle gradient
  background(6, 6, 4);
  drawBackgroundGradient();

  // metaballs shader pass
  if(settings.metaballs){
    // choose a set of blobs (sample by age or random)
    const MAXBLOBS = 30;
    let blobCount = min(MAXBLOBS, floor(particles.length/40));
    let blobPos = new Array(MAXBLOBS*2).fill(0);
    let blobRad = new Array(MAXBLOBS).fill(0);

    // sample few particles distributed through array
    let step = floor(particles.length / (blobCount || 1));
    for(let i=0;i<blobCount;i++){
      let pi = particles[(i*step + (i*13)%particles.length) % particles.length];
      let nx = pi.pos.x/width;
      let ny = 1 - pi.pos.y/height; // flip for WEBGL frag coords
      blobPos[i*2] = nx;
      blobPos[i*2+1] = ny;
      blobRad[i] = map(pi.size,0.5,3,0.035,0.12);
    }

    // pass uniforms
    metaballsShader.setUniform('u_resolution',[width,height]);
    metaballsShader.setUniform('u_time', t);
    metaballsShader.setUniform('u_count', blobCount);
    metaballsShader.setUniform('u_blobs', blobPos);
    metaballsShader.setUniform('u_radii', blobRad);
    metaballsShader.setUniform('u_hueShift', palette.baseHue/360);

    pgMeta.push();
    pgMeta.clear();
    pgMeta.shader(metaballsShader);
    // draw a full-screen rectangle (in WEBGL coords)
    pgMeta.rect(-width/2, -height/2, width, height);
    pgMeta.pop();

    // draw metaballs to screen in additive mode
    push();
    blendMode(ADD);
    image(pgMeta, 0, 0, width, height);
    blendMode(BLEND);
    pop();
  }

  // draw trails on top
  push();
  blendMode(ADD);
  image(pgTrails,0,0);
  pop();

  // overlay subtle vignette
  drawVignette();

  // update UI stats
  fps += (frameRate() - fps) * settings.fpsSmoothing;
  document.getElementById('stats').innerText = `FPS: ${fps.toFixed(0)} • Particles: ${particles.length}`;
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  let w = windowWidth, h = windowHeight;
  pgTrails.resizeCanvas(w,h);
  pgMeta.resizeCanvas(w,h);
}

// ---------------------------
// FlowField class
// ---------------------------
class FlowField{
  constructor(res){
    this.res = res; // cell size
    this.cols = ceil(width/this.res)+1;
    this.rows = ceil(height/this.res)+1;
    this.vectors = new Array(this.cols*this.rows).fill().map(()=>createVector());
    this.scale = 0.0016; // noise scale
  }
  update(time){
    let i=0;
    for(let x=0;x<this.cols;x++){
      for(let y=0;y<this.rows;y++){
        let px = x*this.res;
        let py = y*this.res;
        // fbm/curl-inspired angle
        let n = fbm(px*this.scale, py*this.scale, time*0.12);
        let angle = TAU * n * 1.6 + cos(time*0.05 + n*10.0);
        let v = p5.Vector.fromAngle(angle);
        v.setMag(1);
        this.vectors[i++] = v;
      }
    }
  }
  lookup(pos){
    let col = constrain(floor(pos.x/this.res),0,this.cols-1);
    let row = constrain(floor(pos.y/this.res),0,this.rows-1);
    let idx = col + row*this.cols;
    return this.vectors[idx] ? this.vectors[idx].copy() : createVector(0,0);
  }
}

// ---------------------------
// Particle class
// ---------------------------
class Particle{
  constructor(){
    this.pos = createVector(random(width), random(height));
    this.prev = this.pos.copy();
    this.vel = createVector(0,0);
    this.acc = createVector(0,0);
    this.maxSpeed = random(0.6, 2.6) * settings.speed;
    this.size = random(0.8, 3.6);
    this.hue = (palette.baseHue + random(-30,30) + random(0,30)) % 360;
    this.life = random(20, 200);
  }
  follow(field){
    let desired = field.lookup(this.pos);
    desired.mult(this.maxSpeed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(0.08 + this.size*0.003);
    this.applyForce(steer);

    // attractor from mouse when pressed
    if(mouseIsPressed){
      let m = createVector(mouseX, mouseY);
      let dir = p5.Vector.sub(m, this.pos);
      let d = dir.mag();
      if(d>1){
        dir.normalize();
        // attract stronger when closer
        let strength = map(d,0,width,0.35,0.002);
        dir.mult(strength);
        this.applyForce(dir);
      }
    }
  }
  applyForce(f){ this.acc.add(f); }
  update(dt){
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.prev = this.pos.copy();
    this.pos.add(this.vel.copy().mult(dt*60));
    this.acc.mult(0);
    this.life -= dt*10;
    if(this.life<0) this.reset();
  }
  reset(){
    this.pos.set(random(width), random(height));
    this.prev = this.pos.copy();
    this.vel.mult(0);
    this.life = random(20, 200);
  }
  edges(){
    let wrapped = false;
    if(this.pos.x<0){this.pos.x = width; this.prev.x = this.pos.x; wrapped = true}
    if(this.pos.x>width){this.pos.x = 0; this.prev.x = this.pos.x; wrapped=true}
    if(this.pos.y<0){this.pos.y = height; this.prev.y = this.pos.y; wrapped=true}
    if(this.pos.y>height){this.pos.y = 0; this.prev.y = this.pos.y; wrapped=true}
    if(wrapped) this.vel.mult(0.5);
  }
  show(pg){
    pg.push();
    pg.strokeWeight(this.size);
    // use HSB stroke with alpha that depends on speed
    let s = constrain(this.vel.mag()/this.maxSpeed, 0.1, 1);
    let alpha = map(s,0,1,0.08,0.7);
    pg.stroke(this.hue, 80, 100, alpha);
    pg.line(this.prev.x,this.prev.y,this.pos.x,this.pos.y);
    pg.pop();
  }
}

// ---------------------------
// Utility: palette & helpers
// ---------------------------
class Palette{
  constructor(){
    this.baseHue = random(200, 260); // bluish
  }
}

// fractional brownian motion using p5.noise
function fbm(x,y,z){
  let sum = 0;
  let amp = 0.5;
  let freq = 1.0;
  for(let i=0;i<5;i++){
    sum += amp * noise(x*freq, y*freq, z*freq);
    freq *= 2.0;
    amp *= 0.5;
  }
  return sum;
}

function drawBackgroundGradient(){
  push();
  noFill();
  // subtle radial gradient using rect with low alpha
  for(let i=0;i<60;i++){
    let a = map(i,0,60,0.004,0.0008);
    fill(222, 30, 6, a);
    rectMode(CENTER);
    rect(width/2, height/2, width * (1 + i*0.01), height * (1 + i*0.01));
  }
  pop();
}

function drawVignette(){
  push();
  noFill();
  // simple vignette by drawing transparent radial gradient using blend modes
  let g = 0.35;
  fill(0,0,0,g);
  rect(0,0,width,height);
  pop();
}

function clearTrails(){
  pgTrails.clear();
}

function togglePause(){
  paused = !paused;
  document.getElementById('btnPause').innerText = paused ? 'Resume (P)' : 'Pauze (P)';
}

// keyboard
function keyPressed(){
  if(key==='p' || key==='P') togglePause();
  if(key==='c' || key==='C') clearTrails();
  if(key==='m' || key==='M') settings.metaballs = !settings.metaballs;
}

// mouse wheel to change field scale
function mouseWheel(e){
  let delta = e.delta;
  if(keyIsDown(CONTROL) || keyIsDown(17) || keyIsDown(META)) delta *= 0.2;
  flow.scale = constrain(flow.scale + delta * 0.000002, 0.0004, 0.01);
}

// ---------------------------
// Simple vertex and fragment shaders for metaballs
// embedded as strings
// ---------------------------
const vertSrc = `
  attribute vec3 aPosition;
  void main(){
    gl_Position = vec4(aPosition,1.0);
  }
`;

const fragSrc = `
  precision mediump float;
  uniform vec2 u_resolution;
  uniform float u_time;
  uniform int u_count;
  uniform float u_blobs[60]; // flattened xy pairs (max 30 blobs)
  uniform float u_radii[30];
  uniform float u_hueShift;

  // convert HSB-ish to RGB (approx)
  vec3 hsb2rgb(vec3 c){
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * mix(vec3(1.0), rgb, c.y);
  }

  void main(){
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    // make uv centered
    // accumulate field
    float accum = 0.0;
    for(int i=0;i<30;i++){
      if(i >= u_count) break;
      vec2 p = vec2(u_blobs[i*2], u_blobs[i*2+1]);
      float r = u_radii[i];
      float d = distance(uv, p);
      // soft additive inverse-square influence
      accum += (r*r) / (d*d + 0.0004);
    }
    // tone mapping
    float intensity = 1.0 - exp(-accum * 1.8);

    // color by intensity and a base hue shift
    float hue = mod(u_hueShift + 0.6*intensity, 1.0);
    vec3 col = hsb2rgb(vec3(hue, 0.8, 0.9));
    // final alpha based on intensity
    float a = smoothstep(0.02, 0.65, intensity);
    gl_FragColor = vec4(col * intensity, a * 0.85);
  }
`;

// ------------------------------------------------------------
// End of file
// ------------------------------------------------------------
  </script>
</body>
</html>
